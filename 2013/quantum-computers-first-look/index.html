<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="https://fonts.googleapis.com/css?family=Merriweather:400,700" rel="stylesheet">
  <link href="/assets/main.css?build=2023-06-10T00-25" rel="stylesheet">
  <link rel="canonical" href="https://46b.it/2013/quantum-computers-first-look/">
  <link rel="alternate" type="application/rss+xml" title="46b.it" href="/meta/feed.atom">

  <!-- $if(math)$
  <script src="/js/mathjax/MathJax.js?config=46bit"></script>
  $endif$ -->

  <title>A first look at Quantum Computers - 46b.it</title>
</head>
<body>
  <header id="header">
    <div class="wrapper">
      <h1><a href="/"><img src="/assets/logo.png" alt="46b.it" width="75"></a></h1>
      <nav>
        
        <ul>
          <li ><a href="/art/">art</a></li>
          <li class="active"><a href="/writing/">writing</a></li>
          <li><a href="https://github.com/46bit">github</a></li>
          <li><a href="https://twitter.com/46bit">twitter</a></li>
        </ul>
      </nav>
    </div>
  </header>
  <article>
  <header class="prelude">
    <div class="wrapper">
      <p class="meta">February 11, 2013</p>
      
      <h1>A first look at Quantum Computers</h1>
      
    </div>
  </header>
  <section class="wrapper">
    <p>The computer in front of you is pretty powerful, but it can’t factor a 600-digit number before Earth gets cooked by the Sun. No supercomputer humanity does or could build could do that either, so it seemed a sure bet to base the security of some encryption schemes on factoring being (exponentially) hard.
<!--more--></p>

<p>A quantum computer of sufficient size could do it using <a href="http://en.wikipedia.org/wiki/Shor%27s_algorithm">Shor’s algorithm</a>. It could also allow you to simulate n-body problems in reasonable (polynomial) time. Thus you could break RSA encryption or simulate the interior of the sun right down to the sub-atomic scale.</p>

<p>If you’ve ever looked at Physics like the two-slit experiment, what follows might seem a little reminiscent. That’s because it is.</p>

<h2 id="a-hardwired-machine">A hardwired machine</h2>
<p>In the early days, computers were often programmed by altering their wiring. Instead of running a program stored on disk, computers like <a href="http://en.wikipedia.org/wiki/ENIAC">ENIAC</a> had a number of units that were manually patched together every time you wanted to run a different program. You’d wire a floating-point multiplier up to vacuum tubes with it’s input, then wire the output up to the next stage.</p>

<p>The model of quantum computers looks a lot like that. You’re not going to sit in front of a quantum computer and write some C++ to define the program to run: rather you’ll have to wire it up for every different program. It’s not quite as simple as a metal wire either, since you’ve got to be very careful to not destroy the quantum effects you look to exploit.</p>

<p>I think it should be possible for a 2nd or 3rd generation computer to have this wiring quickly done by another computer, such that you could have most of the benefits of stored-programs. I speculate this mode of operation would be similar to programming modern FPGAs using VHDL, but I’ve not looked for research in this area yet.</p>

<h2 id="what-the-flip-is-a-qubit">What the flip is a qubit?</h2>
<p>A lot of people have heard that the quantum computer’s form of a <code class="language-plaintext highlighter-rouge">bit</code> is called a <code class="language-plaintext highlighter-rouge">qubit</code>. The principle behind them is relatively simple to read about but harder (as with everything in quantum mechanics) to appreciate.</p>

<p>An ordinary <code class="language-plaintext highlighter-rouge">bit</code> is either 0 or 1. There’s no middle ground. A <code class="language-plaintext highlighter-rouge">qubit</code> on the other hand can be both 0 and 1 right up until the moment you observe it. There’s a probability you’ll observe it as a 0, and another probability you’ll observe a 1. This probability as to which state it’s in is called superposition.</p>

<p>How you’d observe a <code class="language-plaintext highlighter-rouge">qubit</code> depends on your implementation of them, but it amounts to when you have an instrument measure their value. This measurement collapses the qubit into a classical state, so if you read the qubit again you’ll read the same value as you did earlier.</p>

<p>Stopping this collapse into classical state from happening to the qubits whilst you’re computing is known as quantum decoherence. It’s one of the greatest problems to building a practical quantum computer.</p>

<p>That’s it for a quick introduction. I’ve had to skip <a href="http://en.wikipedia.org/wiki/Quantum_entanglement">entanglement</a> for now until I’m a bit more comfortable explaining it from the point of view of quantum computation. Possible algorithms, some Math and implementation detail discussion is what I’ll start to discuss next time.</p>

  </section>
  <div class="wrapper prev-next-jump">
    
      <a class="prev" href="/2013/train-data-revisited/">&larr; Railway Data Revisited</a>
    
    
      <a class="next" href="/2013/steady-state-community/">Steady state community &rarr;</a>
    
  </div>
<article>

</body>
</html>
